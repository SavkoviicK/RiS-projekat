package com.veterinarska.stanica.service;

import com.veterinarska.stanica.model.Korisnik;
import com.veterinarska.stanica.model.Poruka;
import com.veterinarska.stanica.repository.KorisnikRepository;
import com.veterinarska.stanica.repository.PorukaRepository;
import com.veterinarska.stanica.repository.PrijateljstvoRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class PorukaService {

    private final PorukaRepository porukaRepo;
    private final KorisnikRepository korisnikRepo;
    private final PrijateljstvoRepository prijateljstvoRepo;

    // === Politika slanja poruka ===
    // Ako je TRUE -> bilo ko bilo kome: moraju biti prijatelji
    // Ako je FALSE -> samo VLASNIK <-> VLASNIK mora biti prijateljstvo (ostale kombinacije su dozvoljene)
    private static final boolean REQUIRE_FRIENDS_FOR_ALL = true; // <— promeni na false za staru varijantu

    public PorukaService(PorukaRepository porukaRepo,
                         KorisnikRepository korisnikRepo,
                         PrijateljstvoRepository prijateljstvoRepo) {
        this.porukaRepo = porukaRepo;
        this.korisnikRepo = korisnikRepo;
        this.prijateljstvoRepo = prijateljstvoRepo;
    }

    @Transactional
    public void posalji(Long posiljalacId, Long primalacId, String sadrzaj) {
        if (posiljalacId == null || primalacId == null) {
            throw new IllegalArgumentException("Nedostaje ID pošiljaoca ili primaoca.");
        }
        if (posiljalacId.equals(primalacId)) {
            throw new IllegalArgumentException("Ne možeš slati poruku samom sebi.");
        }
        String body = (sadrzaj == null ? "" : sadrzaj.trim());
        if (body.isBlank()) {
            throw new IllegalArgumentException("Sadržaj poruke je prazan.");
        }

        Korisnik posiljalac = korisnikRepo.findById(posiljalacId)
                .orElseThrow(() -> new IllegalArgumentException("Pošiljalac ne postoji"));
        Korisnik primalac = korisnikRepo.findById(primalacId)
                .orElseThrow(() -> new IllegalArgumentException("Primalac ne postoji"));

        // Provera pravila prijateljstva
        enforceFriendshipRule(posiljalac, primalac);

        Poruka p = new Poruka();
        p.setPosiljalac(posiljalac);
        p.setPrimalac(primalac);
        p.setSadrzaj(body);
        porukaRepo.save(p);
    }

    @Transactional(readOnly = true)
    public List<Poruka> konverzacija(Long aId, Long bId) {
        if (aId == null || bId == null) {
            throw new IllegalArgumentException("Nedostaje ID korisnika.");
        }
        Korisnik a = korisnikRepo.findById(aId)
                .orElseThrow(() -> new IllegalArgumentException("Korisnik A ne postoji"));
        Korisnik b = korisnikRepo.findById(bId)
                .orElseThrow(() -> new IllegalArgumentException("Korisnik B ne postoji"));

        // I za čitanje istorije primenjujemo isto pravilo
        enforceFriendshipRule(a, b);

        return porukaRepo.konverzacija(a, b);
    }

    private void enforceFriendshipRule(Korisnik a, Korisnik b) {
        // Ako je uključena stroža politika: SVI moraju biti prijatelji
        if (REQUIRE_FRIENDS_FOR_ALL) {
            boolean prijatelji = prijateljstvoRepo.jesuPrijatelji(a.getId(), b.getId());
            if (!prijatelji) {
                throw new IllegalStateException("Poruke su dozvoljene samo između korisnika koji su prijatelji.");
            }
            return;
        }

        // Inače — samo vlasnik↔vlasnik mora biti prijateljstvo, ostale kombinacije su dozvoljene
        String r1 = safeRole(a);
        String r2 = safeRole(b);
        boolean vlasnikVlasnik = "VLASNIK".equals(r1) && "VLASNIK".equals(r2);
        if (vlasnikVlasnik) {
            boolean prijatelji = prijateljstvoRepo.jesuPrijatelji(a.getId(), b.getId());
            if (!prijatelji) {
                throw new IllegalStateException("Vlasnik može slati poruku vlasniku samo ako su prijatelji.");
            }
        }
    }

    private String safeRole(Korisnik k) {
        if (k == null || k.getUloga() == null) return "";
        // Ako je uloga enum, name() je OK; ako je String, koristi toString()
        try {
            return k.getUloga().name().toUpperCase();
        } catch (Exception ignore) {
            return k.getUloga().toString().toUpperCase();
        }
    }
}
